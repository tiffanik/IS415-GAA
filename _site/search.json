[
  {
    "objectID": "In-class_Ex/In-class_Ex11/In-class_Ex11.html",
    "href": "In-class_Ex/In-class_Ex11/In-class_Ex11.html",
    "title": "In-class_Ex11 :Modelling Geographical Accessibility",
    "section": "",
    "text": "pacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n\nalso installing the dependency 'dplyr'\n\n\nWarning: unable to access index for repository http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/4.2:\n  cannot open URL 'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/4.2/PACKAGES'\n\n\npackage 'dplyr' successfully unpacked and MD5 sums checked\n\n\nWarning: cannot remove prior installation of package 'dplyr'\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE): problem\ncopying C:\\R\\R-4.2.2\\library\\00LOCK\\dplyr\\libs\\x64\\dplyr.dll to\nC:\\R\\R-4.2.2\\library\\dplyr\\libs\\x64\\dplyr.dll: Permission denied\n\n\nWarning: restored 'dplyr'\n\n\npackage 'ggstatsplot' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n    C:\\Users\\tiffa\\AppData\\Local\\Temp\\RtmpARtPL0\\downloaded_packages\n\n\n\nggstatsplot installed\n\n\nWarning in pacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse): Failed to install/load:\nggstatsplot\n\n\n\nmpsz = st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\tiffanik\\IS415-GAA\\In-class_Ex\\In-class_Ex11\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n\nReading layer `hexagons' from data source \n  `C:\\tiffanik\\IS415-GAA\\In-class_Ex\\In-class_Ex11\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n\nReading layer `ELDERCARE' from data source \n  `C:\\tiffanik\\IS415-GAA\\In-class_Ex\\In-class_Ex11\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n\n\n\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\n\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n\n\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n\n\n#convert to tratrix, /1000 from m to km\ndistmat_km <- as.matrix(distmat/1000)\n\n\neldercare_coord <- st_coordinates(eldercare)\nhexagon_coord <- st_coordinates(hexagons)\n\nEucMatrix <- SpatialAcc::distance(hexagon_coord,\n                                 eldercare_coord, \n                                 type =\"euclidean\")\n\n\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n\n\ncolnames(acc_Hansen) <- \"accHansen\"\n\n\nacc_Hansen <- tbl_df(acc_Hansen)\n\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nℹ Please use `tibble::as_tibble()` instead.\n\n\n\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n\n\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 0.5, \n                            family = \"Hansen\"))\n\ncolnames(acc_Hansen) <- \"accHansen\"\nacc_Hansen <- tbl_df(acc_Hansen)\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n\n\nmapex <- st_bbox(hexagons)\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n\n\n\n\n\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n\n\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n\n\nNo summary function supplied, defaulting to `mean_se()`"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "title": "Take-home Exercise 3: Predicting HDB Public Housing Resale Pricies using Geographically Weighted Methods",
    "section": "",
    "text": "1 Setting the Scene\nHousing is an essential component of household wealth worldwide. Buying a housing has always been a major investment for most people. The price of housing is affected by many factors. Some of them are global in nature such as the general economy of a country or inflation rate. Others can be more specific to the properties themselves. These factors can be further divided to structural and locational factors. Structural factors are variables related to the property themselves such as the size, fitting, and tenure of the property. Locational factors are variables related to the neighbourhood of the properties such as proximity to childcare centre, public transport service and shopping centre.\nConventional, housing resale prices predictive models were built by using Ordinary Least Square (OLS) method. However, this method failed to take into consideration that spatial autocorrelation and spatial heterogeneity exist in geographic data sets such as housing transactions. With the existence of spatial autocorrelation, the OLS estimation of predictive housing resale pricing models could lead to biased, inconsistent, or inefficient results (Anselin 1998). In view of this limitation, Geographical Weighted Models were introduced for calibrating predictive model for housing resale prices.\nmore than 2 - norminal\nreal world phenominal - no negative variable - dont use linear regression use poson\nlinear regression\n\ncannot use for how many pant want to sell\n-5 covid patience\nfeed straight line - give best fit\nminimise residue , best fit minimise error \nbeta - parameter estimate / slope of independent var , explain how well I explain , slope can be +/- , not show strength but slope will , +/- only show direction\n\nmulti-linear regression\n-one response variable - number / continuous form\n-property price can have decimal\n-dependent var -continuous\ngoodness of fit : bttr if use avg\nf-test stat compare\nreject or fear to reject\n95% confidence interval\np < 0.05 reject\nthis model is btr avg\nmultiple indeV/ explainatory var - use adjusted R\nwhen add in new var r2 increase\n-\nfor map\n{##| fig-width: 30}\n\npacman::p_load(olsrr, ggpubr, sf, spdep, GWmodel, tmap, tidyverse, gtsummary)\n\n\n#dont load this corrplot in pacman install seperately to avoid unneeded confict \n\n\nrequire(dplyr)\n\nresale = st_read(\n  dsn = \"data/aspatial/resale-flat-prices-based-on-registration-date-from-jan-2017-onwards.csv\")\n\nReading layer `resale-flat-prices-based-on-registration-date-from-jan-2017-onwards' from data source `C:\\tiffanik\\IS415-GAA\\Take-home_Ex\\Take-home_Ex03\\data\\aspatial\\resale-flat-prices-based-on-registration-date-from-jan-2017-onwards.csv' \n  using driver `CSV'\n\n\nWarning: no simple feature geometries present: returning a data.frame or tbl_df\n\n# Define vector of values to filter\nfilter_flat_type <- c(\"3 ROOM\", \"4 ROOM\", \"5 ROOM\")\n\nresale_subset <- filter(resale,flat_type  %in% filter_flat_type)%>% \n                 filter(month >= \"2021-01\" & month <= \"2022-12\")\n\n\nrs_transform <- resale_subset %>%\n  mutate(resale_subset, address = paste(block,street_name)) %>%\n  mutate(resale_subset, remaining_lease_yr = as.integer(str_sub(remaining_lease, 0, 2))) %>%\n  mutate(resale_subset, remaining_lease_mth = as.integer(str_sub(remaining_lease, 9, 11)))\n\n\nrs_transform$remaining_lease_mth[is.na(rs_transform$remaining_lease_mth)] <- 0\nrs_transform$remaining_lease_yr <- rs_transform$remaining_lease_yr * 12\nrs_transform <- rs_transform %>% \n  mutate(rs_transform, remaining_lease_mths = rowSums(rs_transform[, c(\"remaining_lease_yr\", \"remaining_lease_mth\")])) %>%\n  select(month, town, address, block, street_name, flat_type, storey_range, floor_area_sqm, flat_model, \n         lease_commence_date, remaining_lease_mths, resale_price)\n\n\nadd_list <- sort(unique(rs_transform$address))\n\n\nget_coords <- function(add_list){\n  \n  # Create a data frame to store all retrieved coordinates\n  postal_coords <- data.frame()\n    \n  for (i in add_list){\n    #print(i)\n\n    r <- GET('https://developers.onemap.sg/commonapi/search?',\n           query=list(searchVal=i,\n                     returnGeom='Y',\n                     getAddrDetails='Y'))\n    data <- fromJSON(rawToChar(r$content))\n    found <- data$found\n    res <- data$results\n    \n    # Create a new data frame for each address\n    new_row <- data.frame()\n    \n    # If single result, append \n    if (found == 1){\n      postal <- res$POSTAL \n      lat <- res$LATITUDE\n      lng <- res$LONGITUDE\n      new_row <- data.frame(address= i, postal = postal, latitude = lat, longitude = lng)\n    }\n    \n    # If multiple results, drop NIL and append top 1\n    else if (found > 1){\n      # Remove those with NIL as postal\n      res_sub <- res[res$POSTAL != \"NIL\", ]\n      \n      # Set as NA first if no Postal\n      if (nrow(res_sub) == 0) {\n          new_row <- data.frame(address= i, postal = NA, latitude = NA, longitude = NA)\n      }\n      \n      else{\n        top1 <- head(res_sub, n = 1)\n        postal <- top1$POSTAL \n        lat <- top1$LATITUDE\n        lng <- top1$LONGITUDE\n        new_row <- data.frame(address= i, postal = postal, latitude = lat, longitude = lng)\n      }\n    }\n\n    else {\n      new_row <- data.frame(address= i, postal = NA, latitude = NA, longitude = NA)\n    }\n    \n    # Add the row\n    postal_coords <- rbind(postal_coords, new_row)\n  }\n  return(postal_coords)\n}\n\n\n#coords <- get_coords(add_list)\n\n\n#coords[(is.na(coords$postal) | is.na(coords$latitude) | is.na(coords$longitude) | coords$postal==\"NIL\"), ]\n\n\n#rs_coords <- left_join(rs_transform, coords, by = c('address' = 'address'))\n\n\n#rs_coords$address <- sub(\"ST. GEORGE'S\", \"SAINT GEORGE'S\", rs_coords$address)\n#rs_invalid <- rs_coords[grepl(\"SAINT GEORGE'S\", rs_coords$address), ]\n\n\n#add_list <- sort(unique(rs_invalid$address))\n\n\n#rs_invalid_coords <- get_coords(add_list)\n\n\n#rs_invalid_coords[(is.na(rs_invalid_coords$postal) | is.na(rs_invalid_coords$latitude) | is.na(rs_invalid_coords$longitude)), ]\n\n\n#rs_coords_final <- rs_coords %>%\n#  left_join(rs_invalid_coords, by = c(\"address\")) %>%\n#  mutate(latitude = ifelse(is.na(postal.x), postal.y, postal.x)) %>%\n # #mutate(latitude = ifelse(is.na(latitude.x), latitude.y, latitude.x)) %>%\n#  mutate(longitude = ifelse(is.na(longitude.x), longitude.y, longitude.x)) %>%\n # select(-c(postal.x, latitude.x, longitude.x, postal.y, latitude.y, longitude.y))\n\n\n#rs_coords_rds <- write_rds(rs_coords_final, \"data/aspatial/rds/rs_coords.rds\")\n\n\n#rs_coords_sf <- st_as_sf(rs_coords,\n         #           coords = c(\"longitude\", \n   # 3                           \"latitude\"),\n     #               crs=4326) %>%\n # st_transform(crs = 3414)\n\n\n#length(which(st_is_valid(rs_coords_sf) == FALSE))\n\n\n#tmap_mode(\"view\")\n#tm_shape(rs_coords_sf)+\n#  tm_dots(col=\"blue\", size = 0.02)\n#tmap_mode(\"plot\")"
  }
]